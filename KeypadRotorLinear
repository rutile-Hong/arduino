#include <Keypad.h>
#include <Servo.h>
#include <EEPROM.h>
#include <RotaryEncoder.h>

/* =====================================================
   Rotary Encoder (KY-040)
   ===================================================== */
#define ENC_CLK 12
#define ENC_DT  11
#define ENC_SW  13

RotaryEncoder encoder(ENC_CLK, ENC_DT, RotaryEncoder::LatchMode::TWO03);

int Counter = 0;                 // live encoder count
const int EEPROM_ADDR = 0;       // address to store Counter

// EEPROM write protection
const unsigned long EEPROM_SAVE_DELAY_MS = 1000;  // save 1s after last change
unsigned long lastEncChangeMs = 0;
bool pendingSave = false;

/* =====================================================
   Keypad 4x4
   ===================================================== */
const byte ROWS = 4;
const byte COLS = 4;

char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};

byte rowPins[ROWS] = {2, 3, 4, 5};
byte colPins[COLS] = {6, 7, 8, 10};

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

/* =====================================================
   Servo (HS-785HB winch)
   ===================================================== */
Servo winch;
const int servoPin = 9;

// For a continuous-rotation/winch servo, 90 is usually stop,
// lower/higher is one direction/other direction (may need tuning).
const int POS_MIN  = 0;    // full speed one direction
const int POS_MAX  = 180;  // full speed other direction
const int POS_STOP = 90;   // stop (adjust if your servo drifts)

/* =====================================================
   Modes (keypad)
   1 = run POS_MAX
   2 = run POS_MIN
   4 = toggle between POS_MAX and POS_MIN every 2 seconds
   5 = stop
   ===================================================== */
char mode = '5';
bool toggleState = false;
unsigned long lastToggleUs = 0;
const unsigned long TOGGLE_INTERVAL_US = 2000000UL;

/* =====================================================
   Encoder button debounce (non-blocking)
   ===================================================== */
bool lastBtnReading = HIGH;
bool btnStableState = HIGH;
unsigned long lastBtnChangeMs = 0;
const unsigned long BTN_DEBOUNCE_MS = 30;

/* =====================================================
   Helpers
   ===================================================== */
void setServoPos(int pos) {
  static int lastPos = -1;
  if (pos != lastPos) {
    winch.write(pos);
    lastPos = pos;
  }
}

void handleSerial() {
  while (Serial.available()) {
    char c = Serial.read();

    if (c == 'r' || c == 'R') {
      int v;
      EEPROM.get(EEPROM_ADDR, v);
      Serial.print("EEPROM Counter=");
      Serial.println(v);
    } else if (c == 'p' || c == 'P') {
      Serial.print("RAM Counter=");
      Serial.println(Counter);
    } else if (c == 'c' || c == 'C') {
      int v = 0;
      EEPROM.put(EEPROM_ADDR, v);
      Counter = 0;
      encoder.setPosition(0);
      Serial.println("EEPROM cleared, counter reset");
    }
  }
}

void handleEncoder() {
  encoder.tick(); // must be called often

  int newPos = encoder.getPosition();
  if (newPos != Counter) {
    Counter = newPos;
    lastEncChangeMs = millis();
    pendingSave = true;

    Serial.print("Encoder count: ");
    Serial.println(Counter);
  }

  // Save to EEPROM only after it stops changing for a while
  if (pendingSave && (millis() - lastEncChangeMs >= EEPROM_SAVE_DELAY_MS)) {
    EEPROM.put(EEPROM_ADDR, Counter);
    pendingSave = false;
    Serial.print("Saved to EEPROM: ");
    Serial.println(Counter);
  }

  // Encoder button debounce (press event)
  bool reading = digitalRead(ENC_SW);
  if (reading != lastBtnReading) {
    lastBtnReading = reading;
    lastBtnChangeMs = millis();
  }
  if ((millis() - lastBtnChangeMs) > BTN_DEBOUNCE_MS) {
    if (reading != btnStableState) {
      btnStableState = reading;
      if (btnStableState == LOW) {
        Serial.println("Encoder button pressed");
        // Optional action: print counter
        Serial.print("Counter=");
        Serial.println(Counter);
      }
    }
  }
}

void handleKeypad() {
  char key = keypad.getKey();
  if (!key) return;

  if (key == '1' || key == '2' || key == '4' || key == '5') {
    mode = key;
    Serial.print("Mode key pressed: ");
    Serial.println(mode);

    if (mode == '5') {
      setServoPos(POS_STOP);
    } else if (mode == '4') {
      toggleState = false;
      lastToggleUs = micros();
      setServoPos(POS_MIN);
    }
  }

  // Optional extra keypad actions:
  // '#' -> print EEPROM
  // '*' -> clear EEPROM/counter
  if (key == '#') {
    int v;
    EEPROM.get(EEPROM_ADDR, v);
    Serial.print("EEPROM Counter=");
    Serial.println(v);
  } else if (key == '*') {
    int v = 0;
    EEPROM.put(EEPROM_ADDR, v);
    Counter = 0;
    encoder.setPosition(0);
    pendingSave = false;
    Serial.println("EEPROM cleared, counter reset");
  }
}

void handleServoControl() {
  if (mode == '1') {
    setServoPos(POS_MAX);
  } else if (mode == '2') {
    setServoPos(POS_MIN);
  } else if (mode == '4') {
    unsigned long now = micros();
    if (now - lastToggleUs >= TOGGLE_INTERVAL_US) {
      lastToggleUs = now;
      toggleState = !toggleState;
      setServoPos(toggleState ? POS_MAX : POS_MIN);
    }
  } else { // '5' or anything else
    setServoPos(POS_STOP);
  }
}

/* =====================================================
   Setup / Loop
   ===================================================== */
void setup() {
  Serial.begin(115200);

  pinMode(ENC_SW, INPUT_PULLUP);

  // Restore encoder count from EEPROM
  EEPROM.get(EEPROM_ADDR, Counter);
  // Basic sanity check (optional; remove if you allow any range)
  if (Counter < -100000 || Counter > 100000) Counter = 0;

  encoder.setPosition(Counter);

  Serial.print("Restored encoder count from EEPROM: ");
  Serial.println(Counter);

  winch.attach(servoPin);
  setServoPos(POS_STOP);

  Serial.println("Commands: r=read EEPROM, p=read RAM, c=clear EEPROM");
}

void loop() {
  handleSerial();
  handleEncoder();
  handleKeypad();
  handleServoControl();

  // No delay: keeps encoder responsive
}
