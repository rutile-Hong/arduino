#include <SPI.h>
#include <SD.h>
#include <Keypad.h>
#include <Servo.h>
#include <RotaryEncoder.h>
#include <EEPROM.h>

/* ================= PEGASUS ACTUATOR(250-9) ================= */
Servo actuator;
const int servoPin = 9;

const int POS_MIN  = 1000;   // retract
const int POS_MAX  = 2000;   // extend
const int POS_STOP = 1500;   // stop (if speed type)

unsigned long actuatorDelay = 900;  // default delay
unsigned long lastChange = 0;
bool extendState = false;

void setActuatorUs(int us) {
  static int lastUs = -1;
  if (us != lastUs) {
    actuator.writeMicroseconds(us);
    lastUs = us;
  }
}

/* ================= SD ================= */
const int SD_CS_PIN = 4;
File logFile;

void sdInitOrHalt() {
  pinMode(10, OUTPUT);
  digitalWrite(10, HIGH);

  if (!SD.begin(SD_CS_PIN)) {
    Serial.println("SD init failed!");
    while (1) {}
  }

  logFile = SD.open("log.csv", FILE_WRITE);
  if (!logFile) {
    Serial.println("log.csv open failed!");
    while (1) {}
  }

  if (logFile.size() == 0) {
    logFile.println("count,timeMs");
    logFile.flush();
  }
}

void sdLogLine(int32_t count, uint32_t timeMs) {
  logFile.print(count);
  logFile.print(",");
  logFile.println(timeMs);
  logFile.flush();
}

/* ================= ENCODER ================= */
#define ENC_CLK 2
#define ENC_DT  3
#define ENC_SW  A0

RotaryEncoder encoder(ENC_CLK, ENC_DT, RotaryEncoder::LatchMode::FOUR3);

volatile bool encChanged = false;
int32_t Counter = 0;

void isrEncoder() {
  encoder.tick();
  encChanged = true;
}

/* ================= EEPROM ================= */
struct Record {
  int32_t  count;
  uint32_t timeMs;
};

void appendRecord(int32_t countVal) {
  uint32_t t = millis();
  sdLogLine(countVal, t);

  Serial.print("Logged: ");
  Serial.print(countVal);
  Serial.print(" @ ");
  Serial.println(t);
}

/* ================= KEYPAD ================= */
const byte ROWS = 4, COLS = 4;

char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};

byte rowPins[ROWS] = {A1, A2, 5, 6};
byte colPins[COLS] = {A3, A4, 7, 8};

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

void handleKeypad() {
  char key = keypad.getKey();
  if (!key) return;

  Serial.print("Key: ");
  Serial.println(key);

  if (key == '1') actuatorDelay = 300;
  if (key == '2') actuatorDelay = 500;
  if (key == '4') actuatorDelay = 700;
  if (key == '5') actuatorDelay = 900;

  if (key == '*') Serial.println("Clear command received");
  if (key == '#') Serial.println("Dump command received");
}

/* ================= ACTUATOR CONTROL ================= */
void handleActuator() {
  if (millis() - lastChange >= actuatorDelay) {
    lastChange = millis();
    extendState = !extendState;

    if (extendState)
      setActuatorUs(POS_MAX);
    else
      setActuatorUs(POS_MIN);
  }
}

/* ================= ENCODER HANDLER ================= */
void handleEncoder() {
  if (!encChanged) return;

  noInterrupts();
  encChanged = false;
  interrupts();

  int32_t newPos = encoder.getPosition();
  if (newPos != Counter) {
    Counter = newPos;
    appendRecord(Counter);
  }
}

/* ================= SETUP ================= */
void setup() {

  Serial.begin(115200);

  pinMode(ENC_CLK, INPUT_PULLUP);
  pinMode(ENC_DT, INPUT_PULLUP);
  pinMode(ENC_SW, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(ENC_CLK), isrEncoder, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENC_DT),  isrEncoder, CHANGE);

  sdInitOrHalt();

  actuator.attach(servoPin);
  setActuatorUs(POS_STOP);

  encoder.setPosition(0);
  Counter = 0;

  Serial.println("System Ready");
  Serial.println("Keypad 1/2/4/5 changes actuator delay");
}

/* ================= LOOP ================= */
void loop() {

  handleKeypad();
  handleEncoder();
  handleActuator();

}
