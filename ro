#include <Keypad.h>        // 1: rotate  2: opposite rotate  4: keep change direction  5: stop at middle
#include <Servo.h>         // HS-785HB
#include <EEPROM.h>        // log rotary encoder count with timestamps
#include <RotaryEncoder.h> // KY-040

/* ================= YOUR PORTS (as you gave) =================
   SD uses UNO SPI pins 11/12/13, so encoder must NOT use 11/12/13.
   Encoder wires:
     CLK -> D2
     DT  -> D3
     SW  -> A0

   Keypad wires (you gave):
     rowPins = {5, 6, A1, A2}
     colPins = {7, 8, A3, A4}

   Servo:
     signal -> D9
*/

/* ================= Rotary Encoder (KY-040) ================= */
#define ENC_CLK 2
#define ENC_DT  3
#define ENC_SW  A0

RotaryEncoder encoder(ENC_CLK, ENC_DT, RotaryEncoder::LatchMode::FOUR3);
int32_t Counter = 0;

/* ================= EEPROM LOG (store ALL records) =================
   EEPROM layout:
   [0..1] uint16_t magic
   [2..3] uint16_t writeIndex (0..MAX_RECORDS-1)
   [4.. ] records array
*/
const uint16_t EEPROM_MAGIC = 0xBEEF;
const int EEPROM_HDR_ADDR = 0;

struct LogHeader {
  uint16_t magic;
  uint16_t writeIndex;
};

struct Record {
  int32_t  count;
  uint32_t timeMs;
  uint16_t crc;
};

uint16_t simpleCrc(const Record &r) {
  uint16_t x = 0x1234;
  x ^= (uint16_t)(r.count & 0xFFFF);
  x ^= (uint16_t)((r.count >> 16) & 0xFFFF);
  x ^= (uint16_t)(r.timeMs & 0xFFFF);
  x ^= (uint16_t)((r.timeMs >> 16) & 0xFFFF);
  return x;
}

const int EEPROM_SIZE = EEPROM.length();
const int RECORDS_BASE_ADDR = EEPROM_HDR_ADDR + (int)sizeof(LogHeader);
const int MAX_RECORDS = (EEPROM_SIZE - RECORDS_BASE_ADDR) / (int)sizeof(Record);

LogHeader hdr;

/* ================= Keypad 4x4 ================= */
const byte ROWS = 4, COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};

// UPDATED to your wiring
byte rowPins[ROWS] = { A1, A2, 5, 6};
byte colPins[COLS] = {A3, A4, 7, 8};

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

/* ================= Servo (HS-785HB winch) ================= */
Servo winch;
const int servoPin = 9;
const int POS_MIN  = 0;
const int POS_MAX  = 180;
const int POS_STOP = 90;

/* ================= Modes (keypad) ================= */
char mode = '5';
bool toggleState = false;
unsigned long lastToggleUs = 0;
const unsigned long TOGGLE_INTERVAL_US = 2000000UL; // 2 seconds

/* ================= Helpers ================= */
void setServoPos(int pos) {
  static int lastPos = -1;
  if (pos != lastPos) {
    winch.write(pos);
    lastPos = pos;
  }
}

int recordAddr(uint16_t index) {
  return RECORDS_BASE_ADDR + index * (int)sizeof(Record);
}

void loadHeader() {
  EEPROM.get(EEPROM_HDR_ADDR, hdr);
  if (hdr.magic != EEPROM_MAGIC || hdr.writeIndex >= MAX_RECORDS) {
    hdr.magic = EEPROM_MAGIC;
    hdr.writeIndex = 0;
    EEPROM.put(EEPROM_HDR_ADDR, hdr);
  }
}

void clearLog() {
  hdr.magic = EEPROM_MAGIC;
  hdr.writeIndex = 0;
  EEPROM.put(EEPROM_HDR_ADDR, hdr);
  Serial.println("Log cleared (index reset to 0)");
}

void appendRecord(int32_t countVal) {
  Record r;
  r.count = countVal;
  r.timeMs = millis();
  r.crc = simpleCrc(r);

  int addr = recordAddr(hdr.writeIndex);
  EEPROM.put(addr, r);

  uint16_t writtenAt = hdr.writeIndex;
  hdr.writeIndex++;
  if (hdr.writeIndex >= MAX_RECORDS) hdr.writeIndex = 0;
  EEPROM.put(EEPROM_HDR_ADDR, hdr);

  Serial.print("Logged @");
  Serial.print(writtenAt);
  Serial.print(": count=");
  Serial.print(r.count);
  Serial.print(" timeMs=");
  Serial.println(r.timeMs);
}

bool readRecord(uint16_t index, Record &out) {
  if (index >= MAX_RECORDS) return false;
  EEPROM.get(recordAddr(index), out);
  return (out.crc == simpleCrc(out));
}

void dumpLog() {
  Serial.print("MAX_RECORDS=");
  Serial.print(MAX_RECORDS);
  Serial.print(" writeIndex=");
  Serial.println(hdr.writeIndex);

  for (uint16_t i = 0; i < MAX_RECORDS; i++) {
    Record r;
    if (readRecord(i, r)) {
      Serial.print(i);
      Serial.print(",count=");
      Serial.print(r.count);
      Serial.print(",timeMs=");
      Serial.println(r.timeMs);
    }
  }
}

/* ================= Serial commands =================
   r = dump all valid records
   c = clear log
   i = info
*/
void handleSerial() {
  while (Serial.available()) {
    char c = Serial.read();
    if (c == 'r' || c == 'R') {
      dumpLog();
    } else if (c == 'c' || c == 'C') {
      clearLog();
      Counter = 0;
      encoder.setPosition(0);
    } else if (c == 'i' || c == 'I') {
      Serial.print("EEPROM_SIZE=");
      Serial.print(EEPROM_SIZE);
      Serial.print(" RECORD_SIZE=");
      Serial.print(sizeof(Record));
      Serial.print(" MAX_RECORDS=");
      Serial.print(MAX_RECORDS);
      Serial.print(" writeIndex=");
      Serial.println(hdr.writeIndex);
    }
  }
}

/* ================= Encoder ================= */
void handleEncoder() {
  encoder.tick();
  int32_t newPos = encoder.getPosition();
  if (newPos != Counter) {
    Counter = newPos;
    appendRecord(Counter); // store EVERY change as a new record
  }
}

/* ================= Keypad ================= */
void handleKeypad() {
  char key = keypad.getKey();
  if (!key) return;

  Serial.print("key: ");
  Serial.println(key);

  if (key == '1' || key == '2' || key == '4' || key == '5') {
    mode = key;

    if (mode == '5') {
      setServoPos(POS_STOP);
    } else if (mode == '4') {
      toggleState = false;
      lastToggleUs = micros();
      setServoPos(POS_MIN);
    }
  }

  if (key == '#') dumpLog();
  if (key == '*') clearLog();
}

/* ================= Servo Control ================= */
void handleServoControl() {
  if (mode == '1') setServoPos(POS_MAX);
  else if (mode == '2') setServoPos(POS_MIN);
  else if (mode == '4') {
    unsigned long now = micros();
    if (now - lastToggleUs >= TOGGLE_INTERVAL_US) {
      lastToggleUs = now;
      toggleState = !toggleState;
      setServoPos(toggleState ? POS_MAX : POS_MIN);
    }
  } else setServoPos(POS_STOP);
}

/* ================= Setup / Loop ================= */
void setup() {
  Serial.begin(115200);

  // Encoder stability
  pinMode(ENC_CLK, INPUT_PULLUP);
  pinMode(ENC_DT, INPUT_PULLUP);
  pinMode(ENC_SW, INPUT_PULLUP);

  loadHeader();
  Serial.print("EEPROM log ready. MAX_RECORDS=");
  Serial.println(MAX_RECORDS);
  Serial.println("Commands: r=dump log, i=info, c=clear");

  winch.attach(servoPin);
  setServoPos(POS_STOP);

  encoder.setPosition(0);
  Counter = 0;
}

void loop() {
  handleSerial();
  handleEncoder();
  handleKeypad();
  handleServoControl();
}
